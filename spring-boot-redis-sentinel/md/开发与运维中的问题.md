模拟故障的方法有很多，比较典型的方法有以下几种： \
·方法一，强制杀掉对应节点的进程号，这样可以模拟出宕机的效果。 \
·方法二，使用Redis的debug sleep命令，让节点进入睡眠状态，这样可以模拟阻塞的效果。 \
·方法三，使用Redis的shutdown命令，模拟正常的停掉Redis。

部署各个节点的机器时间尽量要同步，否则日志的时序性会混乱，例如可以给机器添加NTP服务来同步时间

### 1、高可用读写分离
   * 1️⃣从节点的作用
        从节点一般可以起到两个作用：第一，当主节点出现故障时，作为主节点的后备“顶”上来实现故障转移，Redis Sentinel已经实现了该功能的自动
        化，实现了真正的高可用。第二，扩展主节点的读能力，尤其是在读多写少的场景非常适用。

        因为Redis Sentinel的故障转移是针对主节点的。所以很多时候，Redis Sentinel中的从节点仅仅是作为主节点一个热备，不让它参与客户端的读操作，就是
        为了保证整体高可用性，但实际上这种使用方法还是有一些浪费，尤其是在有很多从节点或者确实需要读写分离的场景，所以如何实现从节点的高可用
        是非常有必要的。

   * 2️⃣Redis Sentinel读写分离设计思路
        Redis Sentinel在对各个节点的监控中，如果有对应事件的发生，都会发出相应的事件消息，其中和从节点变动的事件有以下几个：
        ·+switch-master：切换主节点（原来的从节点晋升为主节点），说明减少了某个从节点。
        ·+convert-to-slave：切换从节点（原来的主节点降级为从节点），说明添加了某个从节点。
        ·+sdown：主观下线，说明可能某个从节点可能不可用（因为对从节点不会做客观下线），所以在实现客户端时可以采用自身策略来实现类似主观下线的功能。
        ·+reboot：重新启动了某个节点，如果它的角色是slave，那么说明添加了某个从节点。

        所以在设计Redis Sentinel的从节点高可用时，只要能够实时掌握所有从节点的状态，把所有从节点看做一个资源池，无论是上线
        还是下线从节点，客户端都能及时感知到（将其从资源池中添加或者删除），这样从节点的高可用目标就达到了。


        Redis Sentinel读写分离需要考虑具体场景，是否真的需要读写分离; redis是内存数据库，不存在关系型数据的IO性能瓶颈；

        基于Spring 的Redis Sentinel读写分离Slave连接池 可参考下面的网址：
        https://www.jack-yin.com/coding/spring-boot/2683.html
